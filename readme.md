# WIP: Poster 版本 Rust 测试应用

警告：该分支的程序**相当**不稳定，客户端与服务端的程序很可能有错误，请谨慎使用。

该分支希望用来测试 DTP 的运行效率以及接入 C 动态库之后的运行效率，从而得出模块化 DTP 的性能优化程度。

该分支希望使得 Rust 版本的测试应用可以发送和接收块的大小极大的数据块，从而测试整体上的发送速率。我们希望看到运行的过程中一个进程可以跑满一个 CPU 。

相对于基础版本而言增加了如下的特性：

1. 会在发送数据包之前发送一个记录“块”总数的数据块（int），客户端会记录这个数量并且在完成块的数量达到设定的数量的时候自动结束程序
2. 通过对 server 的修改，使得其每一次发送大小为 1,000,000B 的数据，最终可以发送 1,000,000 整数倍大小的数据块
  1. 然而这个功能还有不少的 Bug。最核心的问题之一就是它在传送巨大数据块（如 1G）的时候，client 端好像不能完全接收到，但是 server 端说已经发送出去了。这会导致 server 端在最后出现一个 30s 左右的 timeout 并且期间不会做任何事情，同时也无法接收到任何 ACK 数据包。这可能是需要解决的一个问题。
3. 对最后的输出 log 数据进行了检查和调整。

理论上具有以下的功能：

1. 可以利用 DTP 的 FFI 接口，与 C 实现的调度算法等算法进行联合测试【已验证可行】
2. 可以创建镜像并且用于运行得到实验数据【暂时没有测试过】
3. 可以使用 FEC 的功能并且进行测试【暂时没有测试过】

## 重要：Hard Code

为了实现巨大数据块的传输，一部分逻辑以非常简陋的 Hard Code 实现。请注意以下说明的若干地方：

1. server
  1. 481 行附近描述了在发送数据块之前先发送一个记录了当前 cfgs 里面数据块数量的块。
  2. 514 行附近的 while 循环中书写了每一次发送 1000000B 大小的数据，直到将全部数据块发送完毕为止。在 522 行附近检查了发送数据的长度是否和记录的块长度一致。请注意：这段代码逻辑没有任何的地方检查了**如果剩余数据不足 1000000B 如何进行发送**，所以最后只能发送 1000000 整数倍的数据。
  3. 527 行进行了发送数据总量的统计，现在发送数据总量按照服务端发送块的总大小来决定。
  4. 33 行附近增加了一个可以把 i32 转换为 [u8] 的一个函数
  5. 如果要进行本地的运行测试，则需要调节 155 行附近初始窗口大小。**不过这可能会导致一些 BUG，请谨慎使用。**
2. client
  1. 64 行附近添加了 i32 与 [u8] 相互转换的函数
3. demo/solution.cxx
可以发现 SolutionCCTrigger 部分把窗口设置得特别大，这是因为窗口如果不够大可能会导致整个程序无法运行。有的时候 Reno 也不太好使，也会导致发送到一半的时候卡住。解决方法还在研究当中。
## Makefile 提供指令

* `make test`：在本地的 aitrans-server 目录下进行测试，可以得到四个运行结果文件，分别为 `aitrans-server/client.log`、`aitrans-server/client_err.log`、`aitrans-server/log/server.log`、`aitrans-server/server_err.log`
* `make feature_test`: 利用 dtp_server/demo 下的 cpp 代码编译形成动态链接库，将其拷贝到`aitrans-server/lib`目录下并且利用其运行使用 C 接口的服务端程序
* `make image_build`: 创建一个名称由`IMAGE_NAME`决定的镜像，该镜像可以配合 evaluate 目录下的脚本进行测试

## 测试应用与系统大体约定说明

### server

放置于 `aitrans-server/bin` 目录下。

使用方法类似`./bin/server 127.0.0.1 5555 'trace/block_trace/aitrans_block.txt'`，接受至少三个参数：IP,PORT和 TRACE 的路径

输出在 `./log/server_aitrans.log` 中，应具有一定格式的统计信息。（统计信息没有硬性要求）

### client

放置于 `aitrans-server` 目录下。

使用方法类似`./client 127.0.0.1 5555 --no-verify`，需要可以接受 `--no-verify` 参数。需要接受：IP，PORT 两个变量。

输出在 `aitrans-server` 目录下，`client.log` 应符合对应格式，并且最后应该提供具有一定格式的统计信息。（统计信息没有硬性要求）

## 其他说明

1. 如果要进行 FEC 功能的测试，需要修改两个地方：
  1. 修改 `dtp_server/src/main.rs` 下的`config.set_redundancy_rate(f32)`中的值来说明需要进行荣誉编码的比例。如果打算启用 C 语言的调度算法或是拥塞控制，那么需要在 solution.cxx 中修改 `SolutionRedundancy` 函数的返回值来得到相同的结果。
  2. 修改 `dtp_server/src/main.rs` 下 383 行附近的 `conn.set_tail()` 中的数值。其中 tail 代表块的尾部数据，tail_size 代表块尾部数据的大小。通过 `conn.set_tail()** 来设定需要添加冗余的尾部数据大小
2. 现在的 server/client 只能因为**连接超时**的原因断开链接，**这可能会导致额外的测试时间开销**。需要进行检查并且进行一定的修改。
3. 现在采用的测试用镜像基本上会以 aitrans-server 目录为核心进行构建。可以参考 dockerfile 中的写法，只需要提供 server 和 client 的文件即可获得测试用的镜像

